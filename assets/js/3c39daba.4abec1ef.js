"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2139],{13247:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var s=a(5533),t=a(62540),i=a(43023),o=a(78296),r=a(22491);const l={title:"Unlock WebAssembly on macOS & Windows",description:"Spinning a OCI container image containing a WebAssembly/Wasm workload on macOS or Windows should be as simple as running any other OCI image.",slug:"wasm-workloads-on-macos-and-windows-with-podman",authors:["benoitf"],tags:["podman-desktop","wasm","wasi","WebAssembly"],hide_table_of_contents:!1,image:"/img/blog/run-webassembly-wasm-workloads-windows-and-macos/webassembly-podman.webp"},d=void 0,c={authorsImageUrls:[void 0]},u=[{value:"What is WebAssembly ?",id:"what-is-webassembly-",level:2},{value:"The extension of WebAssembly",id:"the-extension-of-webassembly",level:2},{value:"Running WebAssembly outside the browser",id:"running-webassembly-outside-the-browser",level:2},{value:"Using Podman engine with Wasm",id:"using-podman-engine-with-wasm",level:2},{value:"Running Wasm workload with podman",id:"running-wasm-workload-with-podman",level:2},{value:"Setup",id:"setup",level:3},{value:"Running Wasm images",id:"running-wasm-images",level:3},{value:"Building Wasm OCI images with podman",id:"building-wasm-oci-images-with-podman",level:2},{value:"Building with a specific platform/architecture",id:"building-with-a-specific-platformarchitecture",level:3},{value:"Source code",id:"source-code",level:3},{value:"Building Wasm images",id:"building-wasm-images",level:3},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Seamlessly run WebAssembly/Wasm binaries on macOS and Windows"}),"\n",(0,t.jsx)(n.p,{children:"You might have heard excitement recently about Wasm and WASI. Imagine a world where you can effortlessly run Wasm binaries and distribute them using Open Container Initiative (OCI) container images \u2013 a singular image deployable across multiple architectures."}),"\n",(0,t.jsx)(n.p,{children:"Though the concept seemed straightforward, accomplishing this task proved to be quite challenging, particularly on macOS and Windows. The complexity comes from the additional virtual machine running Linux. This machine needs all of the dependencies and prerequisites correctly setup."}),"\n",(0,t.jsx)(n.p,{children:"The wait is over. Our blog post unveils the solution, guiding you through the process of enabling Wasm workloads on both macOS and Windows."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"hero",src:a(957).A+"",width:"960",height:"480"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-is-webassembly-",children:"What is WebAssembly ?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://webassembly.org/",children:"WebAssembly"})," (abbreviated\xa0Wasm) was designed as a portable compilation target for programming languages, improving performance and portability of web applications (including gaming/emulators). Using a low-level binary format instead of JavaScript boosts applications to have near-native performance."]}),"\n",(0,t.jsx)(n.p,{children:"The binary format serves as a compilation target and it allows to use a wider range of programming languages such as C, C++, and Rust. While it was a browser/client technology, now it is evolving beyond the web, for example being adapted for use as a back-end or edge technology (this is for example what happened to Java that was first designed for the client side before landing to the server side)."}),"\n",(0,t.jsx)(n.p,{children:"The Wasm binary format was designed to be secure. Wasm modules are isolated from the rest of the system, and they cannot access any system resources without explicit permission. This makes Wasm modules very safe to run, even in untrusted environments. But on another hand, for developing backend applications, this restriction is limiting the usage of Wasm."}),"\n",(0,t.jsx)(n.h2,{id:"the-extension-of-webassembly",children:"The extension of WebAssembly"}),"\n",(0,t.jsx)(n.p,{children:"WebAssembly System Interface (WASI) was born as an essential complement to WebAssembly."}),"\n",(0,t.jsx)(n.p,{children:"It is a system interface that extends WebAssembly's capabilities beyond the browser, making it suitable for a wider range of environments, including servers, edge devices, and more."}),"\n",(0,t.jsx)(n.p,{children:"While with Wasm you had limited access to the host resources, WASI provides a standard set of system calls, enabling WebAssembly modules to interact with the host operating system in a secure and consistent manner: it includes filesystem access, sockets, and other low-level resources."}),"\n",(0,t.jsx)(n.h2,{id:"running-webassembly-outside-the-browser",children:"Running WebAssembly outside the browser"}),"\n",(0,t.jsx)(n.p,{children:"Wasm has shipped in the major browser engines so the usage of Wasm is possible without any 3rd party addition in the browser land. But when it comes to the edge/system usage, you need to find a virtual machine to run these workloads supporting WASI extension. And there is not only one application to run them, there are several Wasm runtimes such as WasmEdge, Wasmtime, Wasmer, and so on. All runtimes support different CPU architectures."}),"\n",(0,t.jsx)(n.p,{children:"Since WASI is still maturing some of the API provided in these runtimes has not reached the standard, so users need to be careful to write portable applications that do not depend on a given runtime."}),"\n",(0,t.jsx)(n.p,{children:"Besides running Wasm/WASI workloads on your computer, there is also the question of how you package this binary format, share, and distribute it. A\xa0convenient way to distribute and run these workloads is to use OCI images as it provides all the basics: package, storage and distribution of the binaries. Then comes the execution part."}),"\n",(0,t.jsx)(n.h2,{id:"using-podman-engine-with-wasm",children:"Using Podman engine with Wasm"}),"\n",(0,t.jsx)(n.p,{children:'When using containers with Podman on macOS or Windows, you have a virtual machine called a "Podman machine" that is executing a Linux environment. We need to add support for Wasm inside this Linux environment. Podman is using the crun project as its OCI runtime, so crun needs to be able to run or delegate execution to Wasm runtimes. Lucky for us, crun supports Wasm execution.'}),"\n",(0,t.jsxs)(n.p,{children:["From the user's point of view, support for Wasm is provided as an additional platform. So when executing a Wasm workload, we specify as a platform ",(0,t.jsx)(n.code,{children:"--platform=wasi/wasm"})," instead of for example ",(0,t.jsx)(n.code,{children:"--platform=linux/arm64"})," or ",(0,t.jsx)(n.code,{children:"--platform=linux/amd64"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"\u200b"}),"\n",(0,t.jsx)(n.h2,{id:"running-wasm-workload-with-podman",children:"Running Wasm workload with podman"}),"\n",(0,t.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,t.jsxs)(o.A,{groupId:"operating-systems",children:[(0,t.jsxs)(r.A,{value:"win",label:"Windows",children:[(0,t.jsxs)(n.p,{children:["On Windows, ensure that your podman machine is a recent one. You can check using the ",(0,t.jsx)(n.code,{children:"podman version"})," command."]}),(0,t.jsx)(n.p,{children:"Depending on the output of the command, you might have extra steps to do."}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Client's version and server's side version >= v4.7.0: Nothing to do, Wasm support is already there using the wasmedge runtime by default."}),"\n",(0,t.jsx)(n.li,{children:"Client's version >= 4.6.0 but server's side version < 4.7. You need to create a new podman machine using the command podman machine init --now wasm"}),"\n",(0,t.jsxs)(n.li,{children:["Old client/old server (< 4.7.0) or podman not being installed: follow the getting started at\xa0",(0,t.jsx)(n.a,{href:"https://podman.io",children:"podman.io"})]}),"\n"]})]}),(0,t.jsxs)(r.A,{value:"mac",label:"macOS",children:[(0,t.jsxs)(n.p,{children:["On macOS, ensure that your podman machine is a recent one. You can check using the ",(0,t.jsx)(n.code,{children:"podman version"})," command. It requires v4.8+."]}),(0,t.jsx)(n.p,{children:"Depending on the output of the command, you might have extra steps to do."}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Client's version and server's side version >= v4.8.0: Nothing to do, Wasm support is already there using the wasmedge runtime by default."}),"\n",(0,t.jsx)(n.li,{children:"Client's version >= 4.8.0 but server's side version < 4.8. You need to create a new podman machine using the command podman machine init --now wasm"}),"\n",(0,t.jsxs)(n.li,{children:["Old client/old server (< 4.8.0) or podman not being installed: follow the getting started at\xa0",(0,t.jsx)(n.a,{href:"https://podman.io",children:"podman.io"})]}),"\n"]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"running-wasm-images",children:"Running Wasm images"}),"\n",(0,t.jsx)(n.p,{children:"Let's try with a simple hello world sample."}),"\n",(0,t.jsxs)(n.p,{children:["We will use example coming from ",(0,t.jsx)(n.a,{href:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world",children:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world"})]}),"\n",(0,t.jsx)(n.p,{children:"There is already an OCI image on quay.io"}),"\n",(0,t.jsx)(n.p,{children:"To run the workload, we will use the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-shession",children:"$ podman run --platform wasi/wasm quay.io/podman-desktop-demo/wasm-rust-hello-world\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When running the command, you will see a Podman Hello World that was compiled using a Rust project using the println function and compiled into Wasm using ",(0,t.jsx)(n.code,{children:"--target wasm32-wasi"})," parameter at compilation time."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Hello World example running",src:a(51246).A+"",width:"369",height:"286"})}),"\n",(0,t.jsxs)(n.p,{children:["you can omit the\xa0",(0,t.jsx)(n.code,{children:"--platform wasi/wasm"})," flag but in that case you'll get a warning that the platform of the image is not matching the platform of your computer (",(0,t.jsx)(n.code,{children:"WARNING: image platform (wasi/wasm) does not match the expected platform (linux/arm64)"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"From this point, you can run other OCI images using Wasm workloads, not only the podman hello world sample."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"NOTE:"})})," if you don't have the prerequisites installed in your podman machine you will see this error:\xa0",(0,t.jsx)(n.code,{children:"Error: requested OCI runtime crun-wasm is not available: invalid argument"})]}),"\n",(0,t.jsx)(n.p,{children:"In that case you should check that the prerequisites from the previous section are met."}),"\n",(0,t.jsx)(n.h2,{id:"building-wasm-oci-images-with-podman",children:"Building Wasm OCI images with podman"}),"\n",(0,t.jsx)(n.h3,{id:"building-with-a-specific-platformarchitecture",children:"Building with a specific platform/architecture"}),"\n",(0,t.jsx)(n.p,{children:"Running Wasm workload is an interesting use case from a consumer point of view. It helps to consume Wasm binaries. But another interesting case is to distribute and build these Wasm images so anyone could run them quickly."}),"\n",(0,t.jsxs)(n.p,{children:["The goal is to have a minimal image containing only the Wasm binary. For that we will use a multi-stage build. First stage will be the platform to build/compile the ",(0,t.jsx)(n.code,{children:".wasm"})," binary file and the second/last stage will copy the binary to a scratch image."]}),"\n",(0,t.jsxs)(n.p,{children:["When building images it will use by default the architecture of the host operating system. If you are using a Mac computer with ARM chip, then the Linux images will default to ",(0,t.jsx)(n.code,{children:"linux/arm64"}),". Using a mac/intel it will default to ",(0,t.jsx)(n.code,{children:"linux/amd64"})," images. In the case of Wasm workloads, the expected target platform is\xa0",(0,t.jsx)(n.code,{children:"wasi/wasm"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["With podman we can use the flag ",(0,t.jsx)(n.code,{children:"--platform=wasi/wasm"})," on the ",(0,t.jsx)(n.code,{children:"podman build"})," command to specify the system/architecture. But if we do that, it means that if the Dockerfile or Containerfile contains as base image\xa0",(0,t.jsx)(n.code,{children:"FROM docker.io/redhat/ubi9-minimal"}),"\xa0for example it will try to fetch a ",(0,t.jsx)(n.code,{children:"ubi9-minimal"})," image using the ",(0,t.jsx)(n.code,{children:"wasi/wasm"})," platform but of course it does not exist."]}),"\n",(0,t.jsxs)(n.p,{children:["So we need to tweak the Containerfile to include a ",(0,t.jsx)(n.code,{children:"--platform"}),"\xa0directive inside the Containerfile."]}),"\n",(0,t.jsx)(n.p,{children:"Example of\xa0Containerfile:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Dockerfile",children:"FROM --platform=$BUILDPLATFORM docker.io/redhat/ubi9-minimal as builder\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Using this method, we will fetch an image matching our host architecture but as there is still the\xa0 ",(0,t.jsx)(n.code,{children:"--platform=wasi/wasm"}),"\xa0on the command line, the resulting image will use the right platform."]}),"\n",(0,t.jsx)(n.h3,{id:"source-code",children:"Source code"}),"\n",(0,t.jsxs)(n.p,{children:["Here is a simple Containerfile to build a rust application using\xa0wasm32-wasi binary output and a multi-layer OCI image. One layer for the build (installing rust, dependencies and compiling the application) and one scratch layer where we only add the ",(0,t.jsx)(n.code,{children:".wasm"})," output and flag it as the entrypoint."]}),"\n",(0,t.jsxs)(n.p,{children:["Source code is available at ",(0,t.jsx)(n.a,{href:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world",children:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Containerfile"})," content:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Dockerfile",children:'# Build using the host platform (and not target platform wasi/wasm)\nFROM --platform=$BUILDPLATFORM docker.io/redhat/ubi9-minimal as builder\n\n# install rust and Wasm/WASI target\nRUN curl --proto \'=https\' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \\\n\xa0 \xa0 && source "$HOME/.cargo/env" && rustup target add wasm32-wasi\n\n# copy source code\nCOPY Cargo.toml /app/\nCOPY src /app/src\xa0\n\n# change working directory\nWORKDIR /app\n\n# Build\nRUN source "$HOME/.cargo/env" && cd /app && cargo build --target wasm32-wasi --release\n\n# now copy the Wasm binary and flag it as the entrypoint\nFROM scratch\nENTRYPOINT [ "/rust-hello-world.wasm" ]\nCOPY --from=builder /app/target/wasm32-wasi/release/rust-hello.wasm /rust-hello-world.wasm\n\xa0\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Cargo.toml"})," content:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "rust-hello-world"\nversion = "0.1.0"\nedition = "2021"\n\n[[bin]]\nname = "rust-hello"\npath = "src/main.rs"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["And the rust program ",(0,t.jsx)(n.code,{children:"src/main.rs"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'\n  fn main() {\n\n\xa0 \xa0 // use of strings literal for multi-line string\n\xa0 \xa0 // https://doc.rust-lang.org/reference/tokens.html#raw-string-literals\n\n\xa0 \xa0 // ascii art from M\xe1ir\xedn Duffy @mairin\n\xa0 \xa0 let hello = r#"\n!... Hello Podman Wasm World ...!\n\n\xa0 \xa0 \xa0 \xa0 \xa0.--"--.\n\xa0 \xa0 \xa0 \xa0/ - \xa0 \xa0 - \\\n\xa0 \xa0 \xa0 / (O) \xa0 (O) \\\n\xa0 \xa0~~~| -=(,Y,)=- |\n\xa0 \xa0 .---. /` \xa0\\ \xa0 |~~\n\xa0~/ \xa0o \xa0o \\~~~~.----. ~~\n\xa0 | =(X)= |~ \xa0/ (O (O) \\\n\xa0 \xa0~~~~~~~ \xa0~| =(Y_)=- \xa0|\n\xa0 ~~~~ \xa0 \xa0~~~| \xa0 U \xa0 \xa0 \xa0|~~\n\nProject: \xa0 https://github.com/containers/podman\nWebsite: \xa0 https://podman.io\nDocuments: https://docs.podman.io\nTwitter: \xa0 @Podman_io\n"#;\n\xa0 \xa0 println!("{}", hello);\n\xa0 \xa0\xa0\n\xa0 }\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["All the source code is available at\xa0",(0,t.jsx)(n.a,{href:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world",children:"https://github.com/redhat-developer/podman-desktop-demo/tree/main/wasm/rust-hello-world"})]}),"\n",(0,t.jsx)(n.h3,{id:"building-wasm-images",children:"Building Wasm images"}),"\n",(0,t.jsxs)(n.p,{children:["Run the command from the ",(0,t.jsx)(n.code,{children:"wasm/rust-hello-world"})," folder if you cloned the repository or from the directory where all the files are present."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ podman build --platform=wasi/wasm -t rust-hello-world-wasm .\n"})}),"\n",(0,t.jsx)(n.p,{children:"example of output will be :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-console",children:"[1/2] STEP 1/6: FROM docker.io/redhat/ubi9-minimal AS builder\nTrying to pull docker.io/redhat/ubi9-minimal:latest...\nGetting image source signatures\nCopying blob sha256:472e9d218c02b84dcd7425232d8b1ac2928602de2de0efc01a7360d1d42bf2f6\nCopying config sha256:317fc66dad246d1fac6996189a26f85554dc9fc92ca23bf1e7bf10e16ead7c8c\nWriting manifest to image destination\n[1/2] STEP 2/6: RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \xa0 \xa0 && source \"$HOME/.cargo/env\" && rustup target add wasm32-wasi\ninfo: downloading installer\ninfo: profile set to 'default'\ninfo: default host triple is aarch64-unknown-linux-gnu\ninfo: syncing channel updates for 'stable-aarch64-unknown-linux-gnu'\ninfo: latest update on 2023-10-05, rust version 1.73.0 (cc66ad468 2023-10-03)\ninfo: downloading component 'cargo'\ninfo: downloading component 'clippy'\ninfo: downloading component 'rust-docs'\ninfo: downloading component 'rust-std'\ninfo: downloading component 'rustc'\ninfo: downloading component 'rustfmt'\ninfo: installing component 'cargo'\ninfo: installing component 'clippy'\ninfo: installing component 'rust-docs'\ninfo: installing component 'rust-std'\ninfo: installing component 'rustc'\ninfo: installing component 'rustfmt'\ninfo: default toolchain set to 'stable-aarch64-unknown-linux-gnu'\n\n\xa0 stable-aarch64-unknown-linux-gnu installed - rustc 1.73.0 (cc66ad468 2023-10-03)\n\n\nRust is installed now. Great!\n\nTo get started you may need to restart your current shell.\nThis would reload your PATH environment variable to include\nCargo's bin directory ($HOME/.cargo/bin).\n\nTo configure your current shell, run:\nsource \"$HOME/.cargo/env\"\ninfo: downloading component 'rust-std' for 'wasm32-wasi'\ninfo: installing component 'rust-std' for 'wasm32-wasi'\n--\x3e c93a3433d432\n[1/2] STEP 3/6: COPY Cargo.toml /app/\n--\x3e cf4488993835\n[1/2] STEP 4/6: COPY src /app/src\n--\x3e 531b9389857c\n[1/2] STEP 5/6: WORKDIR /app\n--\x3e 23379392f585\n[1/2] STEP 6/6: RUN source \"$HOME/.cargo/env\" && cd /app && cargo build --target wasm32-wasi --release\n\xa0 \xa0Compiling rust-hello-world v0.1.0 (/app)\n\xa0 \xa0 Finished release [optimized] target(s) in 0.15s\n--\x3e e3582e06f45b\n[2/2] STEP 1/3: FROM scratch\n[2/2] STEP 2/3: ENTRYPOINT [ \"/rust-hello-world.wasm\" ]\n--\x3e 069b1742d906\n[2/2] STEP 3/3: COPY --from=builder /app/target/wasm32-wasi/release/rust-hello.wasm /rust-hello-world.wasm\n[2/2] COMMIT rust-hello-world-wasm\n--\x3e e0948298c0be\nSuccessfully tagged localhost/rust-hello-world-wasm:latest\ne0948298c0be20e11da5d92646a2d6453f05e66671f72f0f792c1e1ff8de75ba\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a multi-stage build but at the end we only have a small image containing the Wasm binary."}),"\n",(0,t.jsx)(n.p,{children:"Launch it quickly using"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ podman run rust-hello-world-wasm\n"})}),"\n",(0,t.jsx)(n.p,{children:"and we'll see the expected output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-console",children:'WARNING: image platform (wasi/wasm/v8) does not match the expected platform (linux/arm64)\n\n!... Hello Podman Wasm World ...!\n\n\xa0 \xa0 \xa0 \xa0 \xa0.--"--.\n\xa0 \xa0 \xa0 \xa0/ - \xa0 \xa0 - \\\n\xa0 \xa0 \xa0 / (O) \xa0 (O) \\\n\xa0 \xa0~~~| -=(,Y,)=- |\n\xa0 \xa0 .---. /` \xa0\\ \xa0 |~~\n\xa0~/ \xa0o \xa0o \\~~~~.----. ~~\n\xa0 | =(X)= |~ \xa0/ (O (O) \\\n\xa0 \xa0~~~~~~~ \xa0~| =(Y_)=- \xa0|\n\xa0 ~~~~ \xa0 \xa0~~~| \xa0 U \xa0 \xa0 \xa0|~~\n\nProject: \xa0 https://github.com/containers/podman\nWebsite: \xa0 https://podman.io\nDocuments: https://docs.podman.io\nTwitter: \xa0 @Podman_io\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"\u200b"}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"After witnessing the seamless execution and creation of WebAssembly (Wasm) workloads on both Windows and macOS through the utilization of podman, the possibilities are at your fingertips."}),"\n",(0,t.jsx)(n.p,{children:"Now, the initiative lies with you to embark on your journey of exploring, experimenting, and pushing the boundaries."}),"\n",(0,t.jsx)(n.p,{children:"Run and build new examples and do not hesitate to contribute to the podman community by reporting and discussing these issues."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},22491:(e,n,a)=>{a.d(n,{A:()=>o});a(63696);var s=a(11750);const t={tabItem:"tabItem_wHwb"};var i=a(62540);function o(e){let{children:n,hidden:a,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(t.tabItem,o),hidden:a,children:n})}},78296:(e,n,a)=>{a.d(n,{A:()=>j});var s=a(63696),t=a(11750),i=a(90766),o=a(49519),r=a(14395),l=a(35043),d=a(44544),c=a(94243);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:a}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:a,attributes:s,default:t}}=e;return{value:n,label:a,attributes:s,default:t}}))}(a);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,a])}function h(e){let{value:n,tabValues:a}=e;return a.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:a}=e;const t=(0,o.W6)(),i=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:n,groupId:a});return[(0,l.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})}),[i,t])]}function g(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,i=m(e),[o,l]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=a.find((e=>e.default))??a[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[d,u]=p({queryString:a,groupId:t}),[g,w]=function(e){let{groupId:n}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,i]=(0,c.Dv)(a);return[t,(0,s.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:t}),b=(()=>{const e=d??g;return h({value:e,tabValues:i})?e:null})();(0,r.A)((()=>{b&&l(b)}),[b]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),w(e)}),[u,w,i]),tabValues:i}}var w=a(86681);const b={tabList:"tabList_J5MA",tabItem:"tabItem_l0OV"};var f=a(62540);function x(e){let{className:n,block:a,selectedValue:s,selectValue:o,tabValues:r}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),c=e=>{const n=e.currentTarget,a=l.indexOf(n),t=r[a].value;t!==s&&(d(n),o(t))},u=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;n=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;n=l[a]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":a},n),children:r.map((e=>{let{value:n,label:a,attributes:i}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>l.push(e),onKeyDown:u,onClick:c,...i,className:(0,t.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":s===n}),children:a??n},n)}))})}function y(e){let{lazy:n,children:a,selectedValue:i}=e;const o=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===i));return e?(0,s.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function v(e){const n=g(e);return(0,f.jsxs)("div",{className:(0,t.A)("tabs-container",b.tabList),children:[(0,f.jsx)(x,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function j(e){const n=(0,w.A)();return(0,f.jsx)(v,{...e,children:u(e.children)},String(n))}},957:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/webassembly-podman-e40f6760fbeda109aa109b4a4d926f40.webp"},51246:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/wasm-hello-world-99612b86e6bdb59de87cb1e150e42a37.png"},43023:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var s=a(63696);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},5533:e=>{e.exports=JSON.parse('{"permalink":"/blog/wasm-workloads-on-macos-and-windows-with-podman","source":"@site/blog/2024-01-29-run-webassembly-wasm-workloads-windows-and-macos.md","title":"Unlock WebAssembly on macOS & Windows","description":"Spinning a OCI container image containing a WebAssembly/Wasm workload on macOS or Windows should be as simple as running any other OCI image.","date":"2024-01-29T00:00:00.000Z","tags":[{"inline":true,"label":"podman-desktop","permalink":"/blog/tags/podman-desktop"},{"inline":true,"label":"wasm","permalink":"/blog/tags/wasm"},{"inline":true,"label":"wasi","permalink":"/blog/tags/wasi"},{"inline":true,"label":"WebAssembly","permalink":"/blog/tags/web-assembly"}],"readingTime":10.695,"hasTruncateMarker":true,"authors":[{"name":"Florent Benoit","title":"Principal Software Engineer","url":"https://github.com/benoitf","imageURL":"https://github.com/benoitf.png","key":"benoitf","page":null}],"frontMatter":{"title":"Unlock WebAssembly on macOS & Windows","description":"Spinning a OCI container image containing a WebAssembly/Wasm workload on macOS or Windows should be as simple as running any other OCI image.","slug":"wasm-workloads-on-macos-and-windows-with-podman","authors":["benoitf"],"tags":["podman-desktop","wasm","wasi","WebAssembly"],"hide_table_of_contents":false,"image":"/img/blog/run-webassembly-wasm-workloads-windows-and-macos/webassembly-podman.webp"},"unlisted":false,"prevItem":{"title":"Podman Desktop Wins 2024 DEVIES Award","permalink":"/blog/podman-desktop-wins-devies-award"},"nextItem":{"title":"Podman Desktop 1.7 Release","permalink":"/blog/podman-desktop-release-1.7"}}')}}]);